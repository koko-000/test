<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>ADJUST MACHINE Dashboard</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
<style>
  body { 
    font-family: Arial, sans-serif; 
    margin: 0; 
    background: #f4f6f9; 
  }

  /* container หลัก */
  .container { 
    max-width: 1850px; 
    margin: 0 auto; 
    padding: 1rem; 
    display: flex; 
    flex-direction: column; 
    gap: 1rem; 
  }

  /* chart-row สำหรับ Monthly + Daily ให้ side by side */
  .chart-row {
    display: flex; 
    gap: 1rem; 
    overflow-x: auto; 
    padding-bottom: 1rem;
  }

  /* chart-side สำหรับ Monthly / Daily */
  .chart-side {
    flex: 0 0 700px;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    background: #fff;
    border-radius: 8px;
    padding: 0.5rem;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }

  /* section header */
  .section-header { 
    background: #007bff; 
    color: #fff; 
    font-weight: 700; 
    padding: 6px 8px; 
    border-radius: 6px; 
    font-size: 1rem; 
  }

  /* table-wrapper */
  .table-wrapper { 
    background: #fff; 
    border-radius: 8px; 
    box-shadow: 0 1px 4px rgba(0,0,0,0.08); 
    padding: 4px; 
    overflow-x: auto; 
  }

  /* table */
  table { 
    border-collapse: collapse; 
    width: 100%; 
    font-size: 0.9rem; 
  }

  th, td { 
    border: 1px solid #d0d6de; 
    padding: 6px 8px; 
    text-align: center; 
    white-space: nowrap; 
  }

  tr:nth-child(even) { 
    background: #fbfdff; 
  }

  td:first-child, th:first-child { 
    background: #007bff; 
    color: #fff; 
    position: sticky; 
    left: 0; 
    z-index: 1; 
    font-weight: 700; 
  }

  /* canvas */
  canvas { 
    width: 100% !important; 
    max-height: 500px; 
    background: #fff; 
    border-radius: 8px; 
    padding: 4px; 
  }
</style>
</head>
<body>
<div class="container">
  <div class="chart-row">
    <!-- Monthly Trend -->
    <div class="chart-side">
      <div class="section-header">Adjust Machine : Monthly Trend (2024-Now)</div>
      <canvas id="barChartMonth"></canvas>
      <div class="table-wrapper">
        <table id="tableMonth"></table>
      </div>
    </div>

    <!-- Daily Trend -->
    <div class="chart-side">
      <div class="section-header">Adjust Machine : Daily Trend (LastMonth)</div>
      <canvas id="barChartDay"></canvas>
      <div class="table-wrapper">
        <table id="tableDay"></table>
      </div>
    </div>
  </div>
</div>

<script>
  Chart.register(ChartDataLabels);

  // ฟังก์ชันช่วยเหลือ
  function formatNumber(val, decimals=2) {
    if(val === "" || val == null || isNaN(val)) return "";
    return Number(val).toLocaleString("en-US", { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
  }

  function parseExcelDate(val) {
    if(typeof val === "number") {
      const d = XLSX.SSF.parse_date_code(val);
      if(d) return new Date(d.y, d.m-1, d.d);
    }
    if(typeof val === "string") {
      const d = new Date(val);
      if(!isNaN(d)) return d;
    }
    return null;
  }

  function parseMonthText(val) {
    const match = /([a-zA-Z]+)'(\d{2})/.exec(val);
    if(match) {
      const monthStr = match[1];
      const year = 2000 + parseInt(match[2]);
      const month = new Date(Date.parse(monthStr + " 1, 2000")).getMonth();
      return new Date(year, month, 1);
    }
    return null;
  }

  function formatDateForTable(val, type="day") {
    if(type === "month") return val;
    const d = parseExcelDate(val);
    if(!d) return val;
    if(type === "day") return String(d.getDate()).padStart(2,"0");
    return val;
  }

  // โหลด Excel
  function loadExcel(filePath, callback) {
    fetch(filePath)
      .then(res => res.arrayBuffer())
      .then(data => {
        const wb = XLSX.read(data, { type:"array" });
        const sheet = wb.Sheets[wb.SheetNames[0]];
        const sheetData = XLSX.utils.sheet_to_json(sheet, { header:1, defval:"" });
        const metrics = ["Input Qty.","Scrap. Qty.","% NG.","Reject Content","Adjust M/C","Target"];

        // --- Daily ---
        const startColDay = XLSX.utils.decode_col("ED");
        const endColDay = XLSX.utils.decode_col("FH");
        const dateRowDay = sheetData[25];
        const datesDay = [];
        for(let c=startColDay; c<=endColDay; c++) datesDay.push(dateRowDay[c]);

        const dataArrDay = metrics.map((metric, idx) => {
          const row = sheetData[26+idx];
          const obj = {};
          datesDay.forEach((d, i) => obj[d] = row[startColDay+i] || 0);
          return { metric, values: obj };
        });

        let dailyData = datesDay.map(d => {
          const obj = { Date: d };
          metrics.forEach((m, idx) => {
            let val = dataArrDay[idx].values[d];
            if(val === "" || val == null) val = 0;
            else if(m === "Target") val = Number(val)*100;
            else if(m !== "% NG." && m !== "Reject Content") val = Number(val);
            obj[m] = val;
          });
          const input = Number(obj["Input Qty."]) || 0;
          const scrap = Number(obj["Scrap. Qty."]) || 0;
          obj["% NG."] = input > 0 ? parseFloat(((scrap/input)*100).toFixed(2)) : 0;
          obj["Target"] = parseFloat(obj["Target"].toFixed(2));
          return obj;
        });

        // filter last month
        const validDates = dailyData.map(r => parseExcelDate(r.Date)).filter(d => d);
        const lastDate = validDates.sort((a,b) => b - a)[0];
        const lastMonth = lastDate.getMonth();
        const lastYear = lastDate.getFullYear();
        dailyData = dailyData.filter(r => {
          const d = parseExcelDate(r.Date);
          return d && d.getMonth() === lastMonth && d.getFullYear() === lastYear;
        });

        // --- Monthly ---
        const startColMonth = XLSX.utils.decode_col("DJ");
        const endColMonth = XLSX.utils.decode_col("EC");
        let datesMonth = [];
        const dateRowMonth = sheetData[25];
        for(let c=startColMonth; c<=endColMonth; c++) datesMonth.push(dateRowMonth[c]);
        datesMonth = datesMonth.filter(d => { const dt=parseMonthText(d); return dt && dt.getFullYear()>=2024; })
                               .sort((a,b) => parseMonthText(a) - parseMonthText(b));

        const dataArrMonth = metrics.map((metric, idx) => {
          const row = sheetData[26+idx];
          const obj = {};
          datesMonth.forEach((d,i) => obj[d] = row[startColMonth+i] || 0);
          return { metric, values: obj };
        });

        const monthlyData = datesMonth.map(d => {
          const obj = { Date: d };
          metrics.forEach((m, idx) => {
            let val = dataArrMonth[idx].values[d];
            if(val === "" || val == null) val = 0;
            else if(m === "Target") val = Number(val)*100;
            else if(m !== "% NG." && m !== "Reject Content") val = Number(val);
            obj[m] = val;
          });
          const input = Number(obj["Input Qty."]) || 0;
          const scrap = Number(obj["Scrap. Qty."]) || 0;
          obj["% NG."] = input > 0 ? parseFloat(((scrap/input)*100).toFixed(2)) : 0;
          obj["Target"] = parseFloat(obj["Target"].toFixed(2));
          return obj;
        });

        callback({ dailyData, monthlyData });
      });
  }

  // Render Table Vertical
  function renderTableVertical(tableId, data, type="day") {
    const table = document.getElementById(tableId);
    table.innerHTML = "";
    if(!data.length) return;

    const headersOrder = ["Date","Input Qty.","Scrap. Qty.","% NG.","Reject Content","Adjust M/C","Target"];
    const rows = headersOrder.map(h => {
      const cells = data.map(r => {
        let val = r[h] !== undefined ? r[h] : "";
        if(h === "Date") val = formatDateForTable(val,type);
        else if(h === "Input Qty." || h === "Scrap. Qty." || h === "Adjust M/C") val = (val==="")?"":formatNumber(val,0);
        else if(h === "% NG." || h === "Target") val = (val==="")?"":formatNumber(val,2)+"%";
        return `<td>${val}</td>`;
      }).join("");
      return `<tr><td>${h}</td>${cells}</tr>`;
    }).join("");

    table.innerHTML = `<tbody>${rows}</tbody>`;
  }

  // Chart Functions
  function createChart(ctx, data, isMonth=true) {
  const y1Min = isMonth ? 0.06 : 0;       // Monthly min=0.04, Daily min=0
  const y1Max = isMonth ? 0.16 : 1.2;     // Monthly max=0.14, Daily max=1.2

  return new Chart(ctx, {
    type: "bar",
    data: {
      labels: data.map(r => isMonth ? r["Date"] : formatDateForTable(r["Date"], "day")),
      datasets: [
        {
          label:"Scrap Qty.",
          type:"bar",
          data: data.map(r => Number(r["Scrap. Qty."])),
          backgroundColor:"#FFFACD",
          barPercentage:0.7,
          categoryPercentage:0.6,
          yAxisID:"y",
          order:2,
          datalabels:{ display:false }
        },
        {
          label:"% NG.",
          type:"line",
          data: data.map(r => r["% NG."]),
          borderColor:"Magenta",
          backgroundColor:"rgba(255,0,255,0.2)",
          borderWidth:3,
          tension:0.3,
          yAxisID:"y1",
          order:1,
          fill:false,
          datalabels:{
            display:true, align:'top', anchor:'end', offset:10, rotation:-90,
            color:"Magenta",
            formatter:v => formatNumber(v,2)+"%"
          }
        },
        {
          label:"Target",
          type:"line",
          data: data.map(r => r["Target"]),
          borderColor:"#00FA9A",
          backgroundColor:"rgba(0,250,154,0.2)",
          borderDash:[5,5],
          borderWidth:3,
          tension:0.3,
          yAxisID:"y1",
          order:1,
          fill:false,
          datalabels:{ display:false }
        }
      ]
    },
    options: {
        responsive: true,
        plugins: {
          legend: {
            display: true,
            position: "top",
            align: "center",
            labels: {
              usePointStyle: true,
              pointStyle: function(context) {
                if (context.datasetIndex === 0) return 'rect';
                return 'line';
              },
              padding: 20,
              font: {
                size: 12
              },
              generateLabels: function(chart) {
                const datasets = chart.data.datasets;
                return datasets.map((dataset, index) => {
                  let pointStyle = 'line';
                  let borderDash = [];
                  
                  if (dataset.type === 'bar') {
                    pointStyle = 'rect';
                  } else if (dataset.borderDash) {
                    borderDash = dataset.borderDash;
                  }

                  return {
                    text: dataset.label,
                    fillStyle: dataset.backgroundColor,
                    strokeStyle: dataset.borderColor,
                    lineWidth: dataset.type === 'line' ? 3 : 1,
                    pointStyle: pointStyle,
                    lineDash: borderDash,
                    datasetIndex: index
                  };
                });
              }
            }
          },
          datalabels: {}
        },
        scales: {
          x: {
            ticks: {
              maxRotation: 90,
              minRotation: 90
            }
          },
          y: {
            beginAtZero: true,
            position: "left",
            title: {
              display: true,
              text: "Qty"
            }
          },
          y1: {
            beginAtZero: false,
            min: y1Min,
            max: y1Max,
            position: "right",
            grid: {
              drawOnChartArea: false
            },
            title: {
              display: true,
              text: "%"
            },
            ticks: {
              callback: v => formatNumber(v, 2) + "%"
            }
          }
        }
      }
    });
  }

  // Run
  document.addEventListener("DOMContentLoaded", () => {
    loadExcel("1st'Yield Trend of Adjust machine on Aug'25 (Update 24-Aug-25).xlsx",
      ({ dailyData, monthlyData }) => {
        renderTableVertical("tableMonth", monthlyData, "month");
        createChart(document.getElementById("barChartMonth"), monthlyData, true);

        renderTableVertical("tableDay", dailyData, "day");
        createChart(document.getElementById("barChartDay"), dailyData, false);
    });
  });
</script>
</body>
</html>


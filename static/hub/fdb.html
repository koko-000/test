<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8" />
<title>HUB FDB Fan Motor Dashboard</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
<style>
  * { box-sizing: border-box; }
  body { font-family: Arial, sans-serif; margin: 0; background: #f4f6f9; color: #222; }
  .container { max-width: 1850px; margin: 10px auto; padding: 6px; display: flex; flex-direction: column; gap: 12px; }

  /* ให้ Monthly + Daily อยู่ข้างกัน */
  .chart-row {
    display: flex;
    gap: 1rem;
    overflow-x: auto;
    padding-bottom: 1rem;
  }
  .chart-side {
    flex: 0 0 700px;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    background: #fff;
    border-radius: 8px;
    padding: 0.5rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.12);
  }

  .section-header { background: #007bff; color: #fff; font-weight: 700; padding: 6px 8px; border-radius: 6px; margin-bottom: 4px; font-size: 1rem; }
  .table-wrapper {
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.08);
  padding: 4px;

  overflow-x: auto;   /* ให้มี scroll แนวนอน */
  overflow-y: auto;   /* ถ้าตารางสูงเกิน จะมี scroll แนวตั้งในกล่องเอง */
  max-height: 400px;  /* กำหนดความสูงกล่อง */
}

/* ตารางยังคงเต็มความกว้าง */
table {
  border-collapse: collapse;
  min-width: 700px;
  width: 100%;
  font-size: 0.9rem;
}

  th, td { border: 1px solid #d0d6de; padding: 6px 8px; text-align: center; white-space: nowrap; }
  tr:nth-child(even) { background: #fbfdff; }
  td:first-child, th:first-child {
  background: #007bff;
  color: #fff;
  position: sticky;
  left: 0;
  z-index: 1;
  font-weight: 700;
}

/* sticky header */
table thead th {
  position: sticky;
  top: 0;
  background: #93ffff;
  /*color: #000000d0;*/
  z-index: 2;
}

  canvas { width: 100% !important; max-height: 500px; background: #fff; border-radius: 8px; padding: 4px; }
</style>
</head>
<body>
<div class="container">
  <div class="chart-row">
    <div class="chart-side">
      <div class="section-header">HUB FDB Fan Motor : Monthly Trend (2024-Now)</div>
      <canvas id="monthChart"></canvas>
      <div class="table-wrapper"><table id="monthTable"></table></div>
    </div>
    <div class="chart-side">
      <div class="section-header">HUB FDB Fan Motor : Daily Trend (LastMonth)</div>
      <canvas id="dayChart"></canvas>
      <div class="table-wrapper"><table id="dayTable"></table></div>
    </div>
  </div>
</div>

<script>
Chart.register(ChartDataLabels);

const EXCEL_PATH = `/static/00 Shop 1st'Yield (Hub all) on Aug'25 (Update 24-Aug-25).xlsx`;
const COLOR_PALETTE = [
  '#E6E6FA','#FFDAB9','#C0FF3E','#FFC0CB','#94ff85','#cbe55d','#deaae9','#b5e8ba',
  '#E91E63','#DEB887','#3F51B5','#795548','#FFFACD','#9C27B0','#BA55D3','#8470FF',
  '#FF34B3','#CD5C5C','#EEE8AA','#f28e2b','#BEBEBE','#87CEFA','#FFE4E1','#8B658B',
  '#FFFF00','#B8860B','#FAFAD2','#DCDCDC'
];

const METRIC_KEYWORDS = {
  percent_yield: ['% NG', '%Yield', '% NG.','% First Yield','%Yield NG'],
  second_yield: ['2nd Yield','2nd Yield NG','2nd Yield.','2nd Yield %','2ndYield'],
  target1: ['Target 1st','Target 1st\'yield','Target 1st yield','target 1st'],
  target2: ['Target 2nd','target 2nd','Target 2nd yield','target 2nd yield']
};

function normalizeText(s){ return s ? String(s).trim().replace(/\s+/g,' ').toLowerCase() : ''; }
function cellLooksLikeMonthLabel(v){
  if(v===undefined||v===null) return false;
  const s=String(v).trim();
  if(/[A-Za-z]{3,}['\-]\d{2,4}/.test(s)) return true;
  if(/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i.test(s)) return true;
  if(/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$/.test(s)) return true;
  return false;
}
function parseMonthTextLabel(s){
  if(!s) return null;
  s = String(s).trim();
  let m=/([A-Za-z]+)['\-](\d{2,4})/.exec(s);
  if(m){
    let month=new Date(Date.parse(m[1]+" 1, 2000")).getMonth();
    let year=parseInt(m[2],10);
    if(year<100) year+=2000;
    return new Date(year,month,1);
  }
  m=/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/.exec(s);
  if(m){
    let d=parseInt(m[1],10), mo=parseInt(m[2],10)-1, y=parseInt(m[3],10);
    if(y<100)y+=2000;
    return new Date(y,mo,d);
  }
  const d=new Date(s);
  return isNaN(d)?null:d;
}
function excelDateToJSDate(serial){
  if(typeof serial!=='number')return null;
  const utc_days=Math.floor(serial-25569);
  const utc_value=utc_days*86400;
  const date_info=new Date(utc_value*1000);
  return new Date(date_info.getFullYear(),date_info.getMonth(),date_info.getDate());
}
function colNameToIndex(name){ let index=0; for(let i=0;i<name.length;i++){ index=index*26 + (name.charCodeAt(i)-64); } return index-1; }

let metricsFound={};

function loadAndBuild(){
  fetch(EXCEL_PATH).then(r=>r.arrayBuffer()).then(ab=>{
    const wb=XLSX.read(ab,{type:'array'});
    const sheet=wb.Sheets[wb.SheetNames[11]];
    const aoa=XLSX.utils.sheet_to_json(sheet,{header:1,defval:''});

    // หา header row (เดือน)
    let headerRowIndex=-1;
    for(let r=0;r<Math.min(60,aoa.length);r++){
      let row=aoa[r]||[]; let monthCount=0;
      for(let c=0;c<row.length;c++) if(cellLooksLikeMonthLabel(row[c])) monthCount++;
      if(monthCount>=3){headerRowIndex=r;break;}
    }
    if(headerRowIndex===-1) headerRowIndex=0;
    const headerRow=aoa[headerRowIndex]||[];

    // --- Monthly: filter >=2024 ---
    const parsedDates=[];
    for(let c=1;c<headerRow.length;c++){
      let raw=headerRow[c]; let date=null;
      if(typeof raw==='number') date=excelDateToJSDate(raw)||null;
      if(!date && cellLooksLikeMonthLabel(raw)) date=parseMonthTextLabel(raw);
      if(!date && String(raw).trim().length>0){ const d=new Date(String(raw)); if(!isNaN(d)) date=d; }
      parsedDates.push({col:c,raw, date});
    }

    const allDefects=[];
    for(let r=headerRowIndex+1;r<aoa.length;r++){
      const firstCell=(aoa[r]&&aoa[r][0])!==undefined?aoa[r][0]:'';
      if(firstCell===''||/^total/i.test(String(firstCell))) break;
      if(String(firstCell).trim()!=='') allDefects.push({name:String(firstCell).trim(),rowIndex:r});
    }

    const EXCLUDE_CHART_NAMES = ['Input Qty','Output Qty','Reject Qty','OTHER QC/PROD CHECKING','%Yield NG','Reject Group'];
    const defectsForChart = allDefects.filter(d => !EXCLUDE_CHART_NAMES.includes(d.name));
    const EXCLUDE_TABLE_NAMES = ['%Yield NG','Reject Group'];
    const defectsForTable = allDefects.filter(d => !EXCLUDE_TABLE_NAMES.includes(d.name));

    metricsFound={};
    for(let r=0;r<aoa.length;r++){
      const cell=aoa[r]&&aoa[r][0]?normalizeText(aoa[r][0]):'';
      if(!cell) continue;
      for(const key in METRIC_KEYWORDS)
        for(const kw of METRIC_KEYWORDS[key])
          if(cell.indexOf(kw.toLowerCase())!==-1) metricsFound[key]={rowIndex:r,rawLabel:aoa[r][0]};
    }

    // --- Monthly map >=2024 ---
    const monthMap={};
    parsedDates.forEach(pd=>{
      const dt=pd.date;
      if(dt && dt.getFullYear()>=2024){
        let key = String(dt.getMonth()+1).padStart(2,'0')+'-'+dt.getFullYear();
        if(!monthMap[key]) monthMap[key]={key,samples:[],cols:[]};
        monthMap[key].samples.push(pd);
        monthMap[key].cols.push(pd.col);
      }
    });
    const monthKeysOrdered = Object.values(monthMap)
      .sort((a,b)=>a.samples[0].date - b.samples[0].date)
      .map(x=>x.key);
    const monthly = monthKeysOrdered.map(key=>({label:key,cols:monthMap[key].cols}));
    const monthLabels = monthly.map(m=>m.label);
    const monthLabelsFormatted = monthLabels.map(l=>{
      const [m,y] = l.split('-');
      const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
      return monthNames[Number(m)-1]+"'"+y.slice(2);
    });

    // --- Daily: last 31 days ---
    const dayColsAll=[], dayLabelsAll=[];
    headerRow.forEach((cell,c)=>{
      if(!cellLooksLikeMonthLabel(cell) && cell!==''){
        dayColsAll.push(c);
        dayLabelsAll.push(cell);
      }
    });
    const last31=31;
    const dayCols=dayColsAll.slice(-last31);
    const dayLabels=dayLabelsAll.slice(-last31);

    // Monthly dataset
    const defectDatasetsMonthly = defectsForChart.map((d,idx)=>({
      label:d.name,
      data:monthly.map(m=>{ let s=0; for(const c of m.cols){ const v=aoa[d.rowIndex][c]||0; s+=Number(v)||0;} return s; }),
      backgroundColor:COLOR_PALETTE[idx%COLOR_PALETTE.length],
      stack:'stack1'
    }));

    const metricLineMonthly=[];
    for(const mkey of Object.keys(METRIC_KEYWORDS))
      if(metricsFound[mkey]){
        const r=metricsFound[mkey].rowIndex;
        const arr=monthly.map(m=>{ let s=0; for(const c of m.cols){ const v=aoa[r][c]||0; s+=Number(v)||0; } return s; });
        metricLineMonthly.push({key:mkey,values:arr,rawLabel:metricsFound[mkey].rawLabel});
      }

    // Daily dataset
    const defectDatasetsDaily = defectsForChart.map((d,idx)=>({
      label:d.name,
      data:dayCols.map(c=>Number(aoa[d.rowIndex][c]||0)),
      backgroundColor:COLOR_PALETTE[idx%COLOR_PALETTE.length],
      stack:'stack1'
    }));

    const metricLineDaily=[];
    if(metricsFound['percent_yield']){
      const r = metricsFound['percent_yield'].rowIndex;
      metricLineDaily.push({key:'percent_yield',values:dayCols.map(c=>Number(aoa[r][c]||0)),rawLabel:metricsFound['percent_yield'].rawLabel});
    }

    // Render charts & tables
    renderMonthChart(monthLabelsFormatted, defectDatasetsMonthly, metricLineMonthly);
    renderDayChart(dayLabels, defectDatasetsDaily, metricLineDaily);
    buildTableFromDefects('monthTable', monthLabelsFormatted, defectsForTable, monthly.map(m=>m.cols), aoa);
    buildTableFromDefects('dayTable', dayLabels, defectsForTable, dayCols.map(c=>[c]), aoa,true);

  }).catch(err=>{console.error(err); alert('ไม่สามารถโหลดไฟล์ Excel ได้: '+err.message);});
}

// ---------------- Chart & Table functions ----------------
let monthChartObj=null, dayChartObj=null;
function renderMonthChart(labels,defectDatasets,metricLines){
  const ctx=document.getElementById('monthChart').getContext('2d');
  if(monthChartObj) monthChartObj.destroy();
  monthChartObj = new Chart(ctx, composeMonthChartConfig(labels, defectDatasets, metricLines, 'Monthly'));
}
function renderDayChart(labels,defectDatasets,metricLines){
  const ctx=document.getElementById('dayChart').getContext('2d');
  if(dayChartObj) dayChartObj.destroy();
  dayChartObj = new Chart(ctx, composeDayChartConfig(labels, defectDatasets, metricLines, 'Daily'));
}

function buildTableFromDefects(tableId,labels,defects,monthColsList,aoa,isDay=false){
  const table=document.getElementById(tableId); table.innerHTML='';
  const thead=document.createElement('thead'); const headerRow=document.createElement('tr');
  const firstTh=document.createElement('th'); firstTh.textContent='Date'; headerRow.appendChild(firstTh);
  labels.forEach(lbl=>{ const th=document.createElement('th'); th.textContent=lbl; headerRow.appendChild(th); });
  thead.appendChild(headerRow); table.appendChild(thead);

  const tbody=document.createElement('tbody');
  defects.forEach(d=>{
    const tr=document.createElement('tr');
    const th=document.createElement('th'); th.textContent=d.name; tr.appendChild(th);
    monthColsList.forEach(colsArr=>{
      let s=0;
      for(const c of colsArr){ const v = aoa[d.rowIndex][c]; s += v!=='' && v!==undefined ? Number(v)||0 : 0; }
      const td=document.createElement('td');
      // -----> Qty: แสดงเป็นจำนวนเต็ม
      td.textContent = s.toLocaleString('en-US');
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });

  const extraMetrics = [
  { key: 'percent_yield', label: '%Yield NG' },
  { key: 'second_yield', label: '2nd Yield NG' },
  { key: 'target1', label: "Target 1st'yield" },
  { key: 'target2', label: "Target 2nd'yield" }
];

extraMetrics.forEach(m=>{
  if(metricsFound[m.key]){
    const r = metricsFound[m.key].rowIndex;
    const tr=document.createElement('tr');
    const th=document.createElement('th'); th.textContent=m.label; tr.appendChild(th);

    monthColsList.forEach(colsArr=>{
      const td=document.createElement('td');
      // ดึงค่า column เดียวตรง ๆ (colsArr มักเป็น array, ใช้ colsArr[0] สำหรับ metric)
      const rawValue = aoa[r][colsArr[0]] || 0;
      td.textContent = m.key.includes('target') || m.key.includes('yield') 
                        ? Number(rawValue).toFixed(2)+'%' 
                        : Number(rawValue).toLocaleString('en-US');
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  }
});

  table.appendChild(tbody);
}


function composeMonthChartConfig(labels, defectDatasets, metricLines, title) {
  const datasets = [];
  defectDatasets.forEach(ds => datasets.push({...ds,type:'bar',stack:'stack1',order:2,datalabels:{display:false}}));
  metricLines.forEach((ml,i)=>{
    const color=['#8470FF','#00FF00','#FF00FF','#ff8c00'][i%4];
    const dashStyles=[[],[5,5],[],[5,5]]; // empty = solid, [5,5]=dash
    datasets.push({
      label: ml.rawLabel || ml.key,
      type: 'line',
      data: ml.values.map(v => Number(v)),
      borderColor: color,
      backgroundColor: Chart.helpers.color(color).alpha(0.15).rgbString(),
      borderWidth: 3,
      borderDash: dashStyles[i % dashStyles.length],
      tension: 0.2,
      yAxisID: 'y1',
      pointRadius: 4,
      pointBackgroundColor: '#eeeeee',
      pointBorderColor: color,
      pointBorderWidth: 2,
      fill: false,
      order: 1,
      datalabels: { display: false }
    });
  });

  return {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true,
      plugins: {
        legend: {
          position: 'top',
          labels: {
            usePointStyle: true,
            generateLabels: function(chart) {
              return chart.data.datasets.map((dataset, index) => {
                let pointStyle = 'line';
                if(dataset.type === 'bar') pointStyle = 'rectRounded'; // bar → แท่ง
                // line dash → line + lineDash
                const lineDash = dataset.borderDash || [];
                return {
                  text: dataset.label,
                  fillStyle: dataset.backgroundColor,
                  strokeStyle: dataset.borderColor,
                  lineWidth: dataset.type==='line'?3:1,
                  pointStyle: pointStyle,
                  lineDash: lineDash,
                  datasetIndex: index
                };
              });
            }
          }
        },
        title: { display: false, text: title },
        datalabels: { display: false }
      },
      scales: {
        x: { stacked: true, ticks: { maxRotation: 90, minRotation: 90, autoSkip: false } },
        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Qty' }, ticks: { callback: val => Number(val).toFixed(2) } },
        y1: { stacked: false, beginAtZero: false, min: 98, max: 100, position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: '%' }, ticks: { callback: val => Number(val).toFixed(2) } }
      }
    }
  };
}

function composeMonthChartConfig(labels, defectDatasets, metricLines, title) {
  const datasets = [];
  defectDatasets.forEach(ds => datasets.push({...ds,type:'bar',stack:'stack1',order:2,datalabels:{display:false}}));
  metricLines.forEach((ml,i)=>{
    const color=['#8470FF','#00FF00','#FF00FF','#ff8c00'][i%4];
    const dashStyles=[[],[20,10],[],[20,10]]; // empty = solid, [20,10]=dash
    datasets.push({
      label: ml.rawLabel || ml.key,
      type: 'line',
      data: ml.values.map(v => Number(v)),
      borderColor: color,
      backgroundColor: Chart.helpers.color(color).alpha(0.15).rgbString(),
      borderWidth: 3,
      borderDash: dashStyles[i % dashStyles.length],
      tension: 0.2,
      yAxisID: 'y1',
      pointRadius: 4,
      pointBackgroundColor: '#eeeeee',
      pointBorderColor: color,
      pointBorderWidth: 2,
      fill: false,
      order: 1,
      datalabels:{
      display: true,       // ✅ แสดงตัวเลขบน line
      color: color,
      align: 'top',
      font: { size: 12, weight: 'bold' },
      formatter: val => val.toFixed(2)+'%'  // format %
    }
    });
  });

  return {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true,
      plugins: {
        legend: {
          position: 'top',
          labels: {
            usePointStyle: true,
            generateLabels: function(chart) {
              return chart.data.datasets.map((dataset, index) => {
                let pointStyle = 'line';
                if(dataset.type === 'bar') pointStyle = 'rectRounded'; // bar → แท่ง
                // line dash → line + lineDash
                const lineDash = dataset.borderDash || [];
                return {
                  text: dataset.label,
                  fillStyle: dataset.backgroundColor,
                  strokeStyle: dataset.borderColor,
                  lineWidth: dataset.type==='line'?3:1,
                  pointStyle: pointStyle,
                  lineDash: lineDash,
                  datasetIndex: index
                };
              });
            }
          }
        },
        title: { display: false, text: title },
        datalabels: { display: false }
      },
      scales: {
        x: { stacked: true, ticks: { maxRotation: 90, minRotation: 90, autoSkip: false } },
        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Qty' }, ticks: { callback: val => Number(val).toFixed(2) } },
        y1: { stacked: false, beginAtZero: false, min: 98, max: 100, position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: '%' }, ticks: { callback: val => Number(val).toFixed(2) } }
      }
    }
  };
}

function composeDayChartConfig(labels, defectDatasets, metricLines, title) {
  const datasets = [];
  defectDatasets.forEach(ds => datasets.push({...ds,type:'bar',stack:'stack1',order:2,datalabels:{display:false}}));
  metricLines.forEach((ml,i)=>{
    datasets.push({
      label: ml.rawLabel || ml.key,
      type: 'line',
      data: ml.values.map(v => Number(v)),
      borderColor: "Magenta",
      backgroundColor: "rgba(255,0,255,0.2)",
      borderWidth: 3,
      tension: 0.2,
      yAxisID: "y1",
      order: 1,
      datalabels:{
      display:true,       // ✅ แสดงตัวเลขบน line
      color:'#FF00FF',
      align:'top',
      font:{size:12,weight:'bold'},
      formatter: val => val.toFixed(2)+'%'
    }
    });
  });

  return {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true,
      plugins: {
        legend: {
          position: 'top',
          labels: {
            usePointStyle: true,
            generateLabels: function(chart) {
              return chart.data.datasets.map((dataset, index) => {
                let pointStyle = 'line';
                if(dataset.type==='bar') pointStyle='rectRounded';
                const lineDash = dataset.borderDash || [];
                return {
                  text: dataset.label,
                  fillStyle: dataset.backgroundColor,
                  strokeStyle: dataset.borderColor,
                  lineWidth: dataset.type==='line'?3:1,
                  pointStyle: pointStyle,
                  lineDash: lineDash,
                  datasetIndex: index
                };
              });
            }
          }
        },
        title: { display: false, text: title },
        datalabels: { display: false }
      },
      scales: {
        x: { stacked: true, ticks: { maxRotation: 90, minRotation: 90, autoSkip: false } },
        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Qty' }, ticks: { callback: val => Number(val).toFixed(2) } },
        y1: { stacked: false, beginAtZero: false, min: 0, max: 12, position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: '%' } }
      }
    }
  };
}

window.addEventListener('load',loadAndBuild);
</script>
</body>
</html>
